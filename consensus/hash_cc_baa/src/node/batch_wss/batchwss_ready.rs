use std::{time::SystemTime};

use async_recursion::async_recursion;
use types::{Replica, hash_cc::{CoinMsg, CTRBCMsg}};

use crate::node::{Context};
use crypto::hash::{Hash};

impl Context {
    #[async_recursion]
    pub async fn process_batchwssready(self: &mut Context, ctrbc:CTRBCMsg,master_root:Hash,ready_sender:Replica){
        let now = SystemTime::now();
        let vss_state = &mut self.batchvss_state;
        let sec_origin = ctrbc.origin;
        log::info!("Received READY message from {} for secret from {}",ready_sender,ctrbc.origin);
        // Highly unlikely that the node will get an echo before rbc_init message
        // If RBC already terminated, do not consider this RBC
        if vss_state.terminated_secrets.contains(&sec_origin){
            log::info!("Terminated secretsharing of instance {} already, skipping this echo",sec_origin);
            return;
        }
        match vss_state.node_secrets.get(&sec_origin){
            None => {
                vss_state.add_ready(sec_origin, ready_sender, &ctrbc);
                return;
            }
            Some(_x) =>{}
        }
        let mp = vss_state.node_secrets.get(&sec_origin).unwrap().master_root;
        if mp != master_root || !ctrbc.verify_mr_proof(){
            log::error!("Merkle root of WSS Init from {} did not match Merkle root of READY from {}",sec_origin,self.myid);
            return;
        }
        vss_state.add_ready(sec_origin, ready_sender, &ctrbc);
        let res = vss_state.ready_check(sec_origin, self.num_nodes.clone(), self.num_faults.clone(), self.batch_size.clone());
        match res.1{
            None => {
                return;
            }
            Some(root_vec) =>{
                if res.0 == self.num_faults +1{
                    let shard = vss_state.echos.get(&sec_origin).unwrap().get(&self.myid).unwrap();
                    let ctrbc = CTRBCMsg::new(shard.0.clone(), shard.1.clone(), 0, sec_origin);
                    vss_state.add_ready(sec_origin, self.myid, &ctrbc);
                    self.broadcast(CoinMsg::BatchWSSReady(ctrbc.clone(),root_vec.0, self.myid)).await;
                    self.process_batchwssready(ctrbc.clone(), master_root, self.myid).await;
                }
                else if res.0 == self.num_nodes-self.num_faults {
                    let shard = vss_state.echos.get(&sec_origin).unwrap().get(&self.myid).unwrap();
                    let ctrbc = CTRBCMsg::new(shard.0.clone(), shard.1.clone(), 0, sec_origin);
                    self.broadcast(CoinMsg::BatchWSSReconstruct(ctrbc.clone(),master_root.clone(), self.myid)).await;
                    self.process_batchreconstruct_message(ctrbc,master_root.clone(),self.myid).await;
                }
                else {
                    return;
                }
            }
        }
        
        // let readys = vss_state.readys.get_mut(&rbc_origin).unwrap();
        // // 2. Check if readys reached the threshold, init already received, and round number is matching
        // log::debug!("READY check: readys.len {}, contains key: {}"
        // ,readys.len(),vss_state.node_secrets.contains_key(&rbc_origin));
        // if readys.len() == self.num_faults+1 &&
        //     vss_state.node_secrets.contains_key(&rbc_origin) && !readys.contains_key(&self.myid){
        //     // Broadcast readys, otherwise, just wait longer
        //     // Cachin-Tessaro RBC implies verification needed
        //     let merkle_root = vss_state.node_secrets.get(&sec_origin).unwrap().master_root.clone();
        //     let mut ready_map = HashMap::default();
        //     for (rep,(shard,_mp)) in readys.clone().into_iter(){
        //         ready_map.insert(rep, shard);
        //     }
        //     let res = 
        //         reconstruct_and_return(&ready_map, self.num_nodes.clone(), self.num_faults.clone());
        //     match res {
        //         Err(error)=> log::error!("Shard reconstruction failed because of the following reason {:?}",error),
        //         Ok(vec_x)=> {
        //             // Further verify the merkle root generated by these hashes
        //             let mut vec_xx = vec_x;
        //             vec_xx.truncate(self.batch_size*32);
        //             log::info!("Vec_x: {:?} {}",vec_xx.clone(),vec_xx.len());
        //             let split_vec:Vec<Hash> = 
        //                 vec_xx.chunks(32).into_iter()
        //                 .map(|x| {
        //                     x.try_into().unwrap()
        //                 })
        //                 .collect();
        //             let merkle_tree_master:MerkleTree<Hash,HashingAlg> = MerkleTree::from_iter(split_vec.clone().into_iter());
        //             if merkle_tree_master.root() == merkle_root{
        //                 let shard = vss_state.echos.get(&sec_origin).unwrap().get(&self.myid).unwrap();
        //                 let ctrbc = CTRBCMsg::new(shard.0.clone(), shard.1.clone(), 0, rbc_origin);
        //                 msgs_to_be_sent.push(CoinMsg::BatchWSSReady(ctrbc,merkle_root, self.myid))
        //             }
        //             else {
        //                 log::error!("Reconstructing root hash polynomial failed, with params {:?} {:?} {:?}", split_vec.clone(),merkle_tree_master.root(),merkle_root);
        //                 return;
        //             }
        //         }
        //     }
        // }
        // else if readys.len() == self.num_nodes-self.num_faults &&
        //     vss_state.node_secrets.contains_key(&rbc_origin){
        //     // Terminate RBC, RAccept the value
        //     // Add value to value list, add rbc to rbc list
        //     let shard = vss_state.echos.get(&sec_origin).unwrap().get(&self.myid).unwrap();
        //     let ctrbc = CTRBCMsg::new(shard.0.clone(), shard.1.clone(), 0, rbc_origin);
        //     msgs_to_be_sent.push(CoinMsg::BatchWSSReconstruct(ctrbc,master_root.clone(), self.myid));
        //     log::info!("Terminated RBC of node {} with value",rbc_origin);
        // }
        self.add_benchmark(String::from("process_batchwssready"), now.elapsed().unwrap().as_nanos());
        // Inserting send message block here to not borrow self as mutable again
        // for prot_msg in msgs_to_be_sent.iter(){
        //     let sec_key_map = self.sec_key_map.clone();
        //     for (replica,sec_key) in sec_key_map.into_iter() {
        //         if replica != self.myid{
        //             let wrapper_msg = WrapperMsg::new(prot_msg.clone(), self.myid, &sec_key.as_slice());
        //             let sent_msg = Arc::new(wrapper_msg);
        //             self.c_send(replica, sent_msg).await;
        //         }
        //         else {
        //             match prot_msg.clone() {
        //                 CoinMsg::BatchWSSReady(ctr,master_root, _sender)=>{
        //                     process_batchwssready(self, ctr.clone(),master_root.clone(),self.myid).await;
        //                 },
        //                 CoinMsg::BatchWSSReconstruct(ctr,master_root, sender) => {
        //                     process_batchreconstruct_message(self,ctr.clone(),master_root.clone(),sender).await;
        //                 }
        //                 _=>{}
        //             }
        //         }
        //     }
        //     log::info!("Broadcasted message {:?}",prot_msg.clone());
        // }
        
    }   
}